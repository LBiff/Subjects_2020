// 给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，
// 您都可以在空白单元格中上、下、左、右移动。
// 如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，
// 并返回通过该路径所需的步数。
// 如果找不到这样的路径，则返回 -1。

#include <vector>
using namespace std;

int shortestPath(vector<vector<int>>& grid, int k)
{
    
}